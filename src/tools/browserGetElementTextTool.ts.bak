/**
 * Browser get element text tool for enhanced text extraction
 * Provides specialized text extraction from specific elements
 */

import {zodToJsonSchema} from 'zod-to-json-schema';
import {BaseTool} from '../core/toolRegistry.js';
import type {BrowserGetElementTextArgs, NavigationToolContext, ToolResult} from '../types/index.js';
import {BrowserGetElementTextArgsSchema} from '../types/index.js';

interface TextExtractionResult {
    primary: string;
    alternatives: {
        textContent: string;
        innerText: string;
        innerHTML: string;
        outerHTML: string;
        value?: string;
    };
    metadata: {
        elementType: string;
        hasChildren: boolean;
        childCount: number;
        characterCount: number;
        wordCount: number;
        lineCount: number;
        isEmpty: boolean;
        isHidden: boolean;
        isFormField: boolean;
    };
    analysis: {
        hasLinks: boolean;
        hasImages: boolean;
        hasFormatting: boolean;
        languageDetection?: string;
        readabilityScore?: number;
        textStructure: {
            paragraphs: number;
            headings: number;
            lists: number;
            tables: number;
        };
    };
    extraction: {
        cleanText: string;
        sentences: string[];
        keywords: string[];
        urls: string[];
        emails: string[];
        phoneNumbers: string[];
    };
}

export class BrowserGetElementTextTool extends BaseTool {
    public readonly name = 'browser_get_element_text';
    public readonly description = 'Extract and analyze text content from specific page elements';
    public readonly inputSchema = zodToJsonSchema(BrowserGetElementTextArgsSchema);

    async execute(args: Record<string, unknown>, context: NavigationToolContext): Promise<ToolResult> {
        const validatedArgs = this.validateArgs<BrowserGetElementTextArgs>(args, BrowserGetElementTextArgsSchema);

        if (!context.pageManager) {
            throw new Error('Page manager not available. Use navigation tools to create a session first.');
        }

        const session = await context.pageManager.getSession(validatedArgs.sessionId);
        if (!session) {
            throw new Error(`Session ${validatedArgs.sessionId} not found`);
        }

        try {
            // Check if element exists
            const elementExists = await session.page.locator(validatedArgs.selector).count() > 0;
            if (!elementExists) {
                throw new Error(`Element not found with selector: ${validatedArgs.selector}`);
            }

            // Extract text with comprehensive analysis
            const textResult = await this.extractElementText(
                session.page,
                validatedArgs.selector,
                validatedArgs.extraction,
                validatedArgs.trim,
                validatedArgs.includeChildren,
                validatedArgs.timeout || context.config.requestTimeout
            );

            // Generate text insights
            const insights = this.generateTextInsights(textResult);

            // Get related elements if applicable
            const relatedElements = await this.getRelatedElements(session.page, validatedArgs.selector);

            // Update session
            session.lastActivity = new Date();

            return this.createResult({
                sessionId: session.id,
                url: session.url,
                navigationHistory: session.navigationHistory,
                hasConsentHandled: session.hasConsentHandled,
                timestamp: new Date().toISOString(),
                textExtraction: {
                    success: true,
                    selector: validatedArgs.selector,
                    extractionType: validatedArgs.extraction,
                    result: textResult,
                    insights,
                    relatedElements,
                    extractionSettings: {
                        trim: validatedArgs.trim,
                        includeChildren: validatedArgs.includeChildren,
                        timeout: validatedArgs.timeout
                    }
                }
            });

        } catch (error) {
            throw new Error(`Text extraction failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async extractElementText(
        page: any,
        selector: string,
        extraction: string,
        trim: boolean,
        includeChildren: boolean,
        timeout: number
    ): Promise<TextExtractionResult> {
        try {
            return await page.evaluate(
                ({ selector, extraction, trim, includeChildren }) => {
                    const element = document.querySelector(selector) as HTMLElement;
                    if (!element) {
                        throw new Error(`Element not found: ${selector}`);
                    }

                    // Get all text extraction methods
                    const alternatives = {
                        textContent: element.textContent || '',
                        innerText: element.innerText || '',
                        innerHTML: element.innerHTML || '',
                        outerHTML: element.outerHTML || '',
                        value: (element as any).value || undefined
                    };

                    // Apply trimming if requested
                    if (trim) {
                        Object.keys(alternatives).forEach(key => {
                            if (typeof alternatives[key as keyof typeof alternatives] === 'string') {
                                alternatives[key as keyof typeof alternatives] = 
                                    (alternatives[key as keyof typeof alternatives] as string).trim();
                            }
                        });
                    }

                    // Get primary text based on extraction method
                    let primary = '';
                    switch (extraction) {
                        case 'textContent':
                            primary = alternatives.textContent;
                            break;
                        case 'innerText':
                            primary = alternatives.innerText;
                            break;
                        case 'innerHTML':
                            primary = alternatives.innerHTML;
                            break;
                        case 'outerHTML':
                            primary = alternatives.outerHTML;
                            break;
                        case 'value':
                            primary = alternatives.value || alternatives.textContent;
                            break;
                        default:
                            primary = alternatives.textContent;
                    }

                    if (!includeChildren && extraction !== 'innerHTML' && extraction !== 'outerHTML') {
                        // Extract only direct text content, excluding children
                        const directText = Array.from(element.childNodes)
                            .filter(node => node.nodeType === Node.TEXT_NODE)
                            .map(node => node.textContent || '')
                            .join(' ');
                        primary = trim ? directText.trim() : directText;
                    }

                    // Metadata analysis
                    const children = Array.from(element.children);
                    const isFormField = ['input', 'textarea', 'select'].includes(element.tagName.toLowerCase());
                    const style = getComputedStyle(element);
                    const isHidden = style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0';

                    const metadata = {
                        elementType: element.tagName.toLowerCase(),
                        hasChildren: children.length > 0,
                        childCount: children.length,
                        characterCount: primary.length,
                        wordCount: primary.split(/\s+/).filter(word => word.length > 0).length,
                        lineCount: primary.split(/\n/).length,
                        isEmpty: primary.trim().length === 0,
                        isHidden,
                        isFormField
                    };

                    // Content analysis
                    const hasLinks = element.querySelectorAll('a').length > 0;
                    const hasImages = element.querySelectorAll('img').length > 0;
                    const hasFormatting = /<[^>]+>/.test(alternatives.innerHTML);

                    const analysis = {
                        hasLinks,
                        hasImages,
                        hasFormatting,
                        languageDetection: this.detectLanguage(primary),
                        readabilityScore: this.calculateReadabilityScore(primary),
                        textStructure: {
                            paragraphs: element.querySelectorAll('p').length,
                            headings: element.querySelectorAll('h1, h2, h3, h4, h5, h6').length,
                            lists: element.querySelectorAll('ul, ol').length,
                            tables: element.querySelectorAll('table').length
                        }
                    };

                    // Text extraction and processing
                    const cleanText = this.cleanText(primary);
                    const sentences = this.extractSentences(cleanText);
                    const keywords = this.extractKeywords(cleanText);
                    const urls = this.extractUrls(primary);
                    const emails = this.extractEmails(primary);
                    const phoneNumbers = this.extractPhoneNumbers(primary);

                    const extraction_result = {
                        cleanText,
                        sentences,
                        keywords,
                        urls,
                        emails,
                        phoneNumbers
                    };

                    return {
                        primary,
                        alternatives,
                        metadata,
                        analysis,
                        extraction: extraction_result
                    };

                    function detectLanguage(text: string): string {
                        // Simple language detection based on common words
                        const cleanText = text.toLowerCase();
                        
                        const patterns = {
                            english: /\b(the|and|or|but|in|on|at|to|for|of|with|by)\b/g,
                            spanish: /\b(el|la|y|o|pero|en|con|por|para|de|que)\b/g,
                            french: /\b(le|la|et|ou|mais|dans|avec|par|pour|de|que)\b/g,
                            german: /\b(der|die|das|und|oder|aber|in|mit|von|zu|für)\b/g,
                            italian: /\b(il|la|e|o|ma|in|con|per|di|che|da)\b/g
                        };

                        let maxMatches = 0;
                        let detectedLanguage = 'unknown';

                        Object.entries(patterns).forEach(([lang, pattern]) => {
                            const matches = (cleanText.match(pattern) || []).length;
                            if (matches > maxMatches) {
                                maxMatches = matches;
                                detectedLanguage = lang;
                            }
                        });

                        return maxMatches > 0 ? detectedLanguage : 'unknown';
                    }

                    function calculateReadabilityScore(text: string): number {
                        // Simple Flesch Reading Ease approximation
                        const words = text.split(/\s+/).filter(word => word.length > 0);
                        const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
                        const syllables = words.reduce((count, word) => {
                            return count + Math.max(1, word.match(/[aeiouy]/gi)?.length || 1);
                        }, 0);

                        if (sentences.length === 0 || words.length === 0) return 0;

                        const avgWordsPerSentence = words.length / sentences.length;
                        const avgSyllablesPerWord = syllables / words.length;

                        const score = 206.835 - (1.015 * avgWordsPerSentence) - (84.6 * avgSyllablesPerWord);
                        return Math.max(0, Math.min(100, score));
                    }

                    function cleanText(text: string): string {
                        return text
                            .replace(/<[^>]*>/g, '') // Remove HTML tags
                            .replace(/\s+/g, ' ') // Normalize whitespace
                            .replace(/[^\w\s.,!?;:\-'"()]/g, '') // Remove special characters except punctuation
                            .trim();
                    }

                    function extractSentences(text: string): string[] {
                        return text
                            .split(/[.!?]+/)
                            .map(sentence => sentence.trim())
                            .filter(sentence => sentence.length > 0)
                            .slice(0, 20); // Limit to first 20 sentences
                    }

                    function extractKeywords(text: string): string[] {
                        const words = text.toLowerCase()
                            .split(/\s+/)
                            .filter(word => word.length > 3)
                            .filter(word => !/^(the|and|for|are|but|not|you|all|can|had|her|was|one|our|out|day|get|use|man|new|now|way|may|say)$/.test(word));

                        const frequency: Record<string, number> = {};
                        words.forEach(word => {
                            frequency[word] = (frequency[word] || 0) + 1;
                        });

                        return Object.entries(frequency)
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 10)
                            .map(([word]) => word);
                    }

                    function extractUrls(text: string): string[] {
                        const urlRegex = /https?:\/\/[^\s<>"]+/gi;
                        return (text.match(urlRegex) || []).slice(0, 10);
                    }

                    function extractEmails(text: string): string[] {
                        const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
                        return (text.match(emailRegex) || []).slice(0, 10);
                    }

                    function extractPhoneNumbers(text: string): string[] {
                        const phoneRegex = /(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/g;
                        return (text.match(phoneRegex) || []).slice(0, 10);
                    }
                },
                { selector, extraction, trim, includeChildren }
            );
        } catch (error) {
            throw new Error(`Failed to extract text: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private generateTextInsights(textResult: TextExtractionResult): any {
        const { metadata, analysis, extraction } = textResult;

        const insights = {
            contentType: this.determineContentType(textResult),
            quality: {
                hasContent: !metadata.isEmpty,
                isSubstantial: metadata.wordCount > 10,
                hasStructure: analysis.textStructure.paragraphs > 0 || analysis.textStructure.headings > 0,
                readabilityLevel: this.getReadabilityLevel(analysis.readabilityScore || 0)
            },
            composition: {
                averageWordLength: metadata.wordCount > 0 ? metadata.characterCount / metadata.wordCount : 0,
                averageSentenceLength: extraction.sentences.length > 0 ? metadata.wordCount / extraction.sentences.length : 0,
                textDensity: metadata.childCount > 0 ? metadata.wordCount / metadata.childCount : metadata.wordCount
            },
            content: {
                hasContactInfo: extraction.emails.length > 0 || extraction.phoneNumbers.length > 0,
                hasLinks: extraction.urls.length > 0,
                hasKeywords: extraction.keywords.length > 0,
                primaryLanguage: analysis.languageDetection
            },
            recommendations: this.generateTextRecommendations(textResult)
        };

        return insights;
    }

    private determineContentType(textResult: TextExtractionResult): string {
        const { metadata, analysis } = textResult;

        if (metadata.isFormField) return 'form-field';
        if (analysis.textStructure.headings > 0) return 'structured-content';
        if (analysis.textStructure.lists > 0) return 'list-content';
        if (analysis.textStructure.tables > 0) return 'tabular-content';
        if (metadata.wordCount > 100) return 'long-form-content';
        if (metadata.wordCount > 10) return 'short-content';
        if (metadata.isEmpty) return 'empty';
        
        return 'text-content';
    }

    private getReadabilityLevel(score: number): string {
        if (score >= 90) return 'very-easy';
        if (score >= 80) return 'easy';
        if (score >= 70) return 'fairly-easy';
        if (score >= 60) return 'standard';
        if (score >= 50) return 'fairly-difficult';
        if (score >= 30) return 'difficult';
        return 'very-difficult';
    }

    private generateTextRecommendations(textResult: TextExtractionResult): string[] {
        const recommendations: string[] = [];
        const { metadata, analysis, extraction } = textResult;

        if (metadata.isEmpty) {
            recommendations.push('Element contains no text content');
        }

        if (metadata.isHidden) {
            recommendations.push('Element is visually hidden - text may not be accessible to users');
        }

        if (metadata.wordCount > 0 && extraction.sentences.length === 0) {
            recommendations.push('Text lacks proper sentence structure');
        }

        if (analysis.readabilityScore && analysis.readabilityScore < 30) {
            recommendations.push('Text may be difficult to read - consider simplifying');
        }

        if (metadata.isFormField && !textResult.primary) {
            recommendations.push('Form field appears to be empty');
        }

        if (analysis.hasLinks && extraction.urls.length === 0) {
            recommendations.push('Contains link elements but no valid URLs detected');
        }

        if (recommendations.length === 0) {
            recommendations.push('Text content appears well-formed');
        }

        return recommendations;
    }

    private async getRelatedElements(page: any, selector: string): Promise<any> {
        try {
            return await page.evaluate((selector: string) => {
                const element = document.querySelector(selector) as HTMLElement;
                if (!element) return null;

                const related = {
                    parent: null as any,
                    siblings: [] as any[],
                    children: [] as any[],
                    labels: [] as any[]
                };

                // Parent element
                if (element.parentElement) {
                    const parent = element.parentElement;
                    related.parent = {
                        tagName: parent.tagName.toLowerCase(),
                        className: parent.className,
                        id: parent.id,
                        textPreview: parent.textContent?.trim().substring(0, 50) || ''
                    };
                }

                // Sibling elements (text-containing siblings)
                if (element.parentElement) {
                    const siblings = Array.from(element.parentElement.children)
                        .filter(sibling => sibling !== element && sibling.textContent?.trim())
                        .slice(0, 5);
                    
                    related.siblings = siblings.map(sibling => ({
                        tagName: sibling.tagName.toLowerCase(),
                        className: sibling.className,
                        id: sibling.id,
                        textPreview: sibling.textContent?.trim().substring(0, 30) || ''
                    }));
                }

                // Child elements with text
                const children = Array.from(element.children)
                    .filter(child => child.textContent?.trim())
                    .slice(0, 10);
                
                related.children = children.map(child => ({
                    tagName: child.tagName.toLowerCase(),
                    className: child.className,
                    id: child.id,
                    textPreview: child.textContent?.trim().substring(0, 30) || ''
                }));

                // Associated labels (for form elements)
                if (element.id) {
                    const labels = document.querySelectorAll(`label[for="${element.id}"]`);
                    related.labels = Array.from(labels).map(label => ({
                        textContent: label.textContent?.trim() || '',
                        className: label.className,
                        id: label.id
                    }));
                }

                return related;
            }, selector);
        } catch (error) {
            return null;
        }
    }
}