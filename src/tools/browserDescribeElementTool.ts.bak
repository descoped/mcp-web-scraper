/**
 * Browser describe element tool for element description generation
 * Provides comprehensive element analysis and description
 */

import {zodToJsonSchema} from 'zod-to-json-schema';
import {BaseTool} from '../core/toolRegistry.js';
import type {BrowserDescribeElementArgs, NavigationToolContext, ToolResult} from '../types/index.js';
import {BrowserDescribeElementArgsSchema} from '../types/index.js';

interface ElementDescription {
    basic: {
        tagName: string;
        id?: string;
        className?: string;
        text: string;
        type?: string;
        role?: string;
        href?: string;
        src?: string;
        value?: string;
    };
    position: {
        boundingBox: {
            x: number;
            y: number;
            width: number;
            height: number;
        };
        viewport: {
            inView: boolean;
            topDistance: number;
            centerDistance: number;
        };
        relative: {
            parentTag: string;
            siblingCount: number;
            childPosition: number;
        };
    };
    styles: {
        computed: {
            display: string;
            visibility: string;
            opacity: string;
            backgroundColor: string;
            color: string;
            fontSize: string;
            fontFamily: string;
            border: string;
            padding: string;
            margin: string;
        };
        layout: {
            boxModel: {
                content: { width: number; height: number };
                padding: { top: number; right: number; bottom: number; left: number };
                border: { top: number; right: number; bottom: number; left: number };
                margin: { top: number; right: number; bottom: number; left: number };
            };
        };
    };
    accessibility: {
        ariaLabel?: string;
        ariaLabelledBy?: string;
        ariaDescribedBy?: string;
        ariaRole?: string;
        tabIndex?: number;
        focusable: boolean;
        hasKeyboardSupport: boolean;
        semanticMeaning: string;
        accessibilityIssues: string[];
    };
    context: {
        parent: {
            tagName: string;
            role?: string;
            text: string;
        };
        siblings: Array<{
            tagName: string;
            text: string;
            position: 'before' | 'after';
        }>;
        children: Array<{
            tagName: string;
            text: string;
            type?: string;
        }>;
        form?: {
            action?: string;
            method?: string;
            name?: string;
        };
        nearbyLabels: string[];
    };
    behavior: {
        isInteractive: boolean;
        hasClickHandler: boolean;
        hasKeyboardHandlers: boolean;
        isFormElement: boolean;
        isNavigational: boolean;
        isContentElement: boolean;
        estimatedPurpose: string;
    };
    humanDescription: string;
}

export class BrowserDescribeElementTool extends BaseTool {
    public readonly name = 'browser_describe_element';
    public readonly description = 'Generate comprehensive description of a page element';
    public readonly inputSchema = zodToJsonSchema(BrowserDescribeElementArgsSchema);

    async execute(args: Record<string, unknown>, context: NavigationToolContext): Promise<ToolResult> {
        const validatedArgs = this.validateArgs<BrowserDescribeElementArgs>(args, BrowserDescribeElementArgsSchema);

        if (!context.pageManager) {
            throw new Error('Page manager not available. Use navigation tools to create a session first.');
        }

        const session = await context.pageManager.getSession(validatedArgs.sessionId);
        if (!session) {
            throw new Error(`Session ${validatedArgs.sessionId} not found`);
        }

        try {
            // Check if element exists
            const elementExists = await session.page.locator(validatedArgs.selector).count() > 0;
            if (!elementExists) {
                throw new Error(`Element not found with selector: ${validatedArgs.selector}`);
            }

            // Get comprehensive element description
            const description = await this.describeElement(
                session.page,
                validatedArgs.selector,
                validatedArgs.includePosition,
                validatedArgs.includeStyles,
                validatedArgs.includeAccessibility,
                validatedArgs.includeContext
            );

            // Generate element summary
            const summary = this.generateElementSummary(description);

            // Get element recommendations
            const recommendations = this.generateRecommendations(description);

            // Update session
            session.lastActivity = new Date();

            return this.createResult({
                sessionId: session.id,
                url: session.url,
                navigationHistory: session.navigationHistory,
                hasConsentHandled: session.hasConsentHandled,
                timestamp: new Date().toISOString(),
                elementDescription: {
                    success: true,
                    selector: validatedArgs.selector,
                    description,
                    summary,
                    recommendations,
                    analysisOptions: {
                        includePosition: validatedArgs.includePosition,
                        includeStyles: validatedArgs.includeStyles,
                        includeAccessibility: validatedArgs.includeAccessibility,
                        includeContext: validatedArgs.includeContext
                    }
                }
            });

        } catch (error) {
            throw new Error(`Element description failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async describeElement(
        page: any,
        selector: string,
        includePosition: boolean,
        includeStyles: boolean,
        includeAccessibility: boolean,
        includeContext: boolean
    ): Promise<ElementDescription> {
        try {
            return await page.evaluate(
                ({ selector, includePosition, includeStyles, includeAccessibility, includeContext }) => {
                    const element = document.querySelector(selector) as HTMLElement;
                    if (!element) {
                        throw new Error(`Element not found: ${selector}`);
                    }

                    const description: ElementDescription = {} as ElementDescription;

                    // Basic information
                    description.basic = {
                        tagName: element.tagName.toLowerCase(),
                        id: element.id || undefined,
                        className: element.className || undefined,
                        text: element.textContent?.trim() || '',
                        type: (element as any).type || undefined,
                        role: element.getAttribute('role') || undefined,
                        href: (element as any).href || undefined,
                        src: (element as any).src || undefined,
                        value: (element as any).value || undefined
                    };

                    // Position information
                    if (includePosition) {
                        const rect = element.getBoundingClientRect();
                        const viewportHeight = window.innerHeight;
                        const viewportWidth = window.innerWidth;

                        description.position = {
                            boundingBox: {
                                x: rect.x,
                                y: rect.y,
                                width: rect.width,
                                height: rect.height
                            },
                            viewport: {
                                inView: rect.top >= 0 && rect.left >= 0 && 
                                       rect.bottom <= viewportHeight && rect.right <= viewportWidth,
                                topDistance: rect.top,
                                centerDistance: Math.abs((rect.top + rect.height / 2) - viewportHeight / 2)
                            },
                            relative: {
                                parentTag: element.parentElement?.tagName.toLowerCase() || 'none',
                                siblingCount: element.parentElement?.children.length || 0,
                                childPosition: Array.from(element.parentElement?.children || []).indexOf(element) + 1
                            }
                        };
                    }

                    // Style information
                    if (includeStyles) {
                        const computedStyle = getComputedStyle(element);
                        
                        description.styles = {
                            computed: {
                                display: computedStyle.display,
                                visibility: computedStyle.visibility,
                                opacity: computedStyle.opacity,
                                backgroundColor: computedStyle.backgroundColor,
                                color: computedStyle.color,
                                fontSize: computedStyle.fontSize,
                                fontFamily: computedStyle.fontFamily,
                                border: computedStyle.border,
                                padding: computedStyle.padding,
                                margin: computedStyle.margin
                            },
                            layout: {
                                boxModel: {
                                    content: {
                                        width: parseFloat(computedStyle.width) || 0,
                                        height: parseFloat(computedStyle.height) || 0
                                    },
                                    padding: {
                                        top: parseFloat(computedStyle.paddingTop) || 0,
                                        right: parseFloat(computedStyle.paddingRight) || 0,
                                        bottom: parseFloat(computedStyle.paddingBottom) || 0,
                                        left: parseFloat(computedStyle.paddingLeft) || 0
                                    },
                                    border: {
                                        top: parseFloat(computedStyle.borderTopWidth) || 0,
                                        right: parseFloat(computedStyle.borderRightWidth) || 0,
                                        bottom: parseFloat(computedStyle.borderBottomWidth) || 0,
                                        left: parseFloat(computedStyle.borderLeftWidth) || 0
                                    },
                                    margin: {
                                        top: parseFloat(computedStyle.marginTop) || 0,
                                        right: parseFloat(computedStyle.marginRight) || 0,
                                        bottom: parseFloat(computedStyle.marginBottom) || 0,
                                        left: parseFloat(computedStyle.marginLeft) || 0
                                    }
                                }
                            }
                        };
                    }

                    // Accessibility information
                    if (includeAccessibility) {
                        const tabIndex = element.getAttribute('tabindex');
                        const focusable = element.tabIndex >= 0 || 
                                        ['input', 'button', 'select', 'textarea', 'a'].includes(element.tagName.toLowerCase());
                        
                        const accessibilityIssues = [];
                        
                        // Check for common accessibility issues
                        if (element.tagName.toLowerCase() === 'img' && !(element as HTMLImageElement).alt) {
                            accessibilityIssues.push('Image missing alt text');
                        }
                        
                        if (focusable && !element.getAttribute('aria-label') && !element.textContent?.trim()) {
                            accessibilityIssues.push('Focusable element lacks accessible name');
                        }

                        if (element.getAttribute('role') === 'button' && !element.getAttribute('aria-label') && !element.textContent?.trim()) {
                            accessibilityIssues.push('Button role without accessible name');
                        }

                        description.accessibility = {
                            ariaLabel: element.getAttribute('aria-label') || undefined,
                            ariaLabelledBy: element.getAttribute('aria-labelledby') || undefined,
                            ariaDescribedBy: element.getAttribute('aria-describedby') || undefined,
                            ariaRole: element.getAttribute('role') || undefined,
                            tabIndex: tabIndex ? parseInt(tabIndex) : undefined,
                            focusable,
                            hasKeyboardSupport: element.hasAttribute('onkeydown') || element.hasAttribute('onkeyup'),
                            semanticMeaning: this.getSemanticMeaning(element),
                            accessibilityIssues
                        };
                    }

                    // Context information
                    if (includeContext) {
                        const parent = element.parentElement;
                        const siblings = parent ? Array.from(parent.children) : [];
                        const children = Array.from(element.children);

                        // Find nearby labels
                        const nearbyLabels: string[] = [];
                        if (element.id) {
                            const label = document.querySelector(`label[for="${element.id}"]`);
                            if (label) {
                                nearbyLabels.push(label.textContent?.trim() || '');
                            }
                        }

                        description.context = {
                            parent: {
                                tagName: parent?.tagName.toLowerCase() || 'none',
                                role: parent?.getAttribute('role') || undefined,
                                text: parent?.textContent?.trim().substring(0, 50) || ''
                            },
                            siblings: siblings
                                .filter(sibling => sibling !== element)
                                .map(sibling => ({
                                    tagName: sibling.tagName.toLowerCase(),
                                    text: sibling.textContent?.trim().substring(0, 30) || '',
                                    position: siblings.indexOf(sibling) < siblings.indexOf(element) ? 'before' as const : 'after' as const
                                }))
                                .slice(0, 5),
                            children: children
                                .map(child => ({
                                    tagName: child.tagName.toLowerCase(),
                                    text: child.textContent?.trim().substring(0, 30) || '',
                                    type: (child as any).type || undefined
                                }))
                                .slice(0, 10),
                            form: element.closest('form') ? {
                                action: element.closest('form')?.getAttribute('action') || undefined,
                                method: element.closest('form')?.getAttribute('method') || undefined,
                                name: element.closest('form')?.getAttribute('name') || undefined
                            } : undefined,
                            nearbyLabels
                        };
                    }

                    // Behavior analysis
                    const isInteractive = this.isInteractiveElement(element);
                    const hasClickHandler = element.hasAttribute('onclick') || 
                                          element.addEventListener !== undefined; // This is a rough check
                    const isFormElement = ['input', 'select', 'textarea', 'button'].includes(element.tagName.toLowerCase());
                    const isNavigational = element.tagName.toLowerCase() === 'a' || 
                                          element.getAttribute('role') === 'link';
                    const isContentElement = ['p', 'div', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(element.tagName.toLowerCase());

                    description.behavior = {
                        isInteractive,
                        hasClickHandler,
                        hasKeyboardHandlers: element.hasAttribute('onkeydown') || element.hasAttribute('onkeyup'),
                        isFormElement,
                        isNavigational,
                        isContentElement,
                        estimatedPurpose: this.estimatePurpose(element)
                    };

                    // Generate human-readable description
                    description.humanDescription = this.generateHumanDescription(element, description);

                    return description;

                    function getSemanticMeaning(element: HTMLElement): string {
                        const role = element.getAttribute('role');
                        if (role) return role;

                        const tagName = element.tagName.toLowerCase();
                        const semanticMap: Record<string, string> = {
                            'button': 'interactive button',
                            'a': 'link',
                            'input': 'form input',
                            'select': 'dropdown selection',
                            'textarea': 'text area',
                            'h1': 'main heading',
                            'h2': 'section heading',
                            'h3': 'subsection heading',
                            'h4': 'minor heading',
                            'h5': 'minor heading',
                            'h6': 'minor heading',
                            'p': 'paragraph',
                            'div': 'container',
                            'span': 'inline text',
                            'img': 'image',
                            'nav': 'navigation',
                            'main': 'main content',
                            'article': 'article content',
                            'aside': 'sidebar content',
                            'footer': 'footer content',
                            'header': 'header content'
                        };

                        return semanticMap[tagName] || 'generic element';
                    }

                    function isInteractiveElement(element: HTMLElement): boolean {
                        const interactiveTags = ['button', 'input', 'select', 'textarea', 'a'];
                        if (interactiveTags.includes(element.tagName.toLowerCase())) return true;
                        if (element.hasAttribute('onclick')) return true;
                        if (element.getAttribute('role') === 'button') return true;
                        if (element.hasAttribute('tabindex') && parseInt(element.getAttribute('tabindex') || '-1') >= 0) return true;
                        return false;
                    }

                    function estimatePurpose(element: HTMLElement): string {
                        const tagName = element.tagName.toLowerCase();
                        const text = element.textContent?.toLowerCase() || '';
                        const type = (element as any).type?.toLowerCase();
                        const className = element.className.toLowerCase();
                        const id = element.id.toLowerCase();

                        // Form elements
                        if (tagName === 'input') {
                            if (type === 'submit') return 'form submission';
                            if (type === 'button') return 'action trigger';
                            if (type === 'text' || type === 'email' || type === 'password') return 'data input';
                            if (type === 'checkbox' || type === 'radio') return 'option selection';
                        }

                        if (tagName === 'button') {
                            if (text.includes('submit') || text.includes('send')) return 'form submission';
                            if (text.includes('close') || text.includes('cancel')) return 'modal/dialog control';
                            if (text.includes('menu') || text.includes('toggle')) return 'navigation control';
                            return 'action trigger';
                        }

                        // Navigation
                        if (tagName === 'a') {
                            return 'navigation link';
                        }

                        // Content
                        if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) {
                            return 'content heading';
                        }

                        if (tagName === 'p') {
                            return 'text content';
                        }

                        // Based on common patterns
                        if (className.includes('nav') || id.includes('nav')) return 'navigation';
                        if (className.includes('menu') || id.includes('menu')) return 'menu';
                        if (className.includes('modal') || id.includes('modal')) return 'modal dialog';
                        if (className.includes('button') || id.includes('button')) return 'interactive button';

                        return 'content display';
                    }

                    function generateHumanDescription(element: HTMLElement, desc: any): string {
                        const tagName = element.tagName.toLowerCase();
                        const text = element.textContent?.trim() || '';
                        const role = element.getAttribute('role');

                        let description = `This is a ${role || tagName} element`;

                        if (text) {
                            description += ` containing the text "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`;
                        }

                        if (desc.basic?.id) {
                            description += ` with ID "${desc.basic.id}"`;
                        }

                        if (desc.behavior?.isInteractive) {
                            description += `. It is interactive and can be clicked or activated`;
                        }

                        if (desc.position && !desc.position.viewport.inView) {
                            description += `. It is currently not visible in the viewport`;
                        }

                        if (desc.accessibility?.accessibilityIssues?.length > 0) {
                            description += `. Note: It has accessibility concerns`;
                        }

                        return description + '.';
                    }
                },
                { selector, includePosition, includeStyles, includeAccessibility, includeContext }
            );
        } catch (error) {
            throw new Error(`Failed to describe element: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private generateElementSummary(description: ElementDescription): string {
        const { basic, behavior, accessibility } = description;
        
        let summary = `${basic.tagName.toUpperCase()}`;
        
        if (basic.role) {
            summary += ` (role: ${basic.role})`;
        }
        
        if (basic.type) {
            summary += ` [${basic.type}]`;
        }
        
        if (behavior.isInteractive) {
            summary += ' - Interactive';
        }
        
        if (behavior.isFormElement) {
            summary += ' - Form Element';
        }
        
        if (accessibility && accessibility.accessibilityIssues.length > 0) {
            summary += ` - ${accessibility.accessibilityIssues.length} A11y Issue(s)`;
        }
        
        return summary;
    }

    private generateRecommendations(description: ElementDescription): string[] {
        const recommendations: string[] = [];
        const { basic, behavior, accessibility, position } = description;

        // Accessibility recommendations
        if (accessibility?.accessibilityIssues.length > 0) {
            recommendations.push(`Address ${accessibility.accessibilityIssues.length} accessibility issue(s): ${accessibility.accessibilityIssues.join(', ')}`);
        }

        // Interaction recommendations
        if (behavior.isInteractive && !accessibility?.focusable) {
            recommendations.push('Consider making this interactive element focusable for keyboard users');
        }

        // Position recommendations
        if (position && !position.viewport.inView) {
            recommendations.push('Element is outside viewport - may need scrolling to interact with it');
        }

        // Selector recommendations
        if (!basic.id && behavior.isInteractive) {
            recommendations.push('Consider adding an ID for easier element selection');
        }

        // Content recommendations
        if (behavior.isInteractive && !basic.text && !accessibility?.ariaLabel) {
            recommendations.push('Interactive element lacks visible text or aria-label');
        }

        if (recommendations.length === 0) {
            recommendations.push('Element appears to be well-formed with no immediate issues');
        }

        return recommendations;
    }
}