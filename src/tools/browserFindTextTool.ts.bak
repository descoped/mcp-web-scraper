/**
 * Browser find text tool for advanced text search
 * Provides comprehensive text finding with multiple strategies
 */

import {zodToJsonSchema} from 'zod-to-json-schema';
import {BaseTool} from '../core/toolRegistry.js';
import type {BrowserFindTextArgs, NavigationToolContext, ToolResult} from '../types/index.js';
import {BrowserFindTextArgsSchema} from '../types/index.js';

interface TextMatch {
    text: string;
    selector: string;
    elementType: string;
    elementId?: string;
    elementClass?: string;
    boundingBox: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
    isVisible: boolean;
    context: {
        parentText: string;
        siblingText: string;
        innerText: string;
    };
}

export class BrowserFindTextTool extends BaseTool {
    public readonly name = 'browser_find_text';
    public readonly description = 'Find text on page using multiple search strategies';
    public readonly inputSchema = zodToJsonSchema(BrowserFindTextArgsSchema);

    async execute(args: Record<string, unknown>, context: NavigationToolContext): Promise<ToolResult> {
        const validatedArgs = this.validateArgs<BrowserFindTextArgs>(args, BrowserFindTextArgsSchema);

        if (!context.pageManager) {
            throw new Error('Page manager not available. Use navigation tools to create a session first.');
        }

        const session = await context.pageManager.getSession(validatedArgs.sessionId);
        if (!session) {
            throw new Error(`Session ${validatedArgs.sessionId} not found`);
        }

        try {
            // Find text matches based on strategy
            const matches = await this.findTextMatches(
                session.page,
                validatedArgs.text,
                validatedArgs.strategy,
                validatedArgs.maxResults,
                validatedArgs.includeHidden,
                validatedArgs.timeout || context.config.requestTimeout
            );

            // Analyze text distribution
            const textAnalysis = await this.analyzeTextDistribution(session.page, validatedArgs.text);

            // Get text context for better understanding
            const textContext = await this.getTextContext(session.page, matches);

            // Update session
            session.lastActivity = new Date();

            return this.createResult({
                sessionId: session.id,
                url: session.url,
                navigationHistory: session.navigationHistory,
                hasConsentHandled: session.hasConsentHandled,
                timestamp: new Date().toISOString(),
                textSearch: {
                    success: true,
                    searchText: validatedArgs.text,
                    strategy: validatedArgs.strategy,
                    totalMatches: matches.length,
                    visibleMatches: matches.filter(m => m.isVisible).length,
                    hiddenMatches: matches.filter(m => !m.isVisible).length,
                    matches: matches.slice(0, validatedArgs.maxResults),
                    analysis: textAnalysis,
                    context: textContext,
                    searchSettings: {
                        maxResults: validatedArgs.maxResults,
                        includeHidden: validatedArgs.includeHidden,
                        timeout: validatedArgs.timeout
                    }
                }
            });

        } catch (error) {
            throw new Error(`Text search failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async findTextMatches(
        page: any,
        searchText: string,
        strategy: string,
        maxResults: number,
        includeHidden: boolean,
        timeout: number
    ): Promise<TextMatch[]> {
        try {
            return await page.evaluate(
                ({ searchText, strategy, maxResults, includeHidden }: { searchText: string; strategy: string; maxResults: number; includeHidden: boolean }) => {
                    const matches: TextMatch[] = [];
                    
                    // Create search regex based on strategy
                    let searchRegex: RegExp;
                    switch (strategy) {
                        case 'exact':
                            searchRegex = new RegExp(`^${searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}$`);
                            break;
                        case 'partial':
                            searchRegex = new RegExp(searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                            break;
                        case 'regex':
                            try {
                                searchRegex = new RegExp(searchText, 'i');
                            } catch {
                                searchRegex = new RegExp(searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                            }
                            break;
                        case 'case-insensitive':
                            searchRegex = new RegExp(searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                            break;
                        default:
                            searchRegex = new RegExp(searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                    }

                    // Get all text nodes
                    const walker = document.createTreeWalker(
                        document.body,
                        NodeFilter.SHOW_TEXT,
                        null,
                        false
                    );

                    const textNodes: Text[] = [];
                    let node: Node | null;
                    while (node = walker.nextNode()) {
                        textNodes.push(node as Text);
                    }

                    // Process each text node
                    for (const textNode of textNodes) {
                        if (matches.length >= maxResults) break;

                        const text = textNode.textContent || '';
                        if (!text.trim() || !searchRegex.test(text)) continue;

                        const parentElement = textNode.parentElement;
                        if (!parentElement) continue;

                        // Check visibility
                        const style = getComputedStyle(parentElement);
                        const isVisible = style.display !== 'none' && 
                                         style.visibility !== 'hidden' && 
                                         style.opacity !== '0';

                        if (!includeHidden && !isVisible) continue;

                        // Get bounding box
                        const rect = parentElement.getBoundingClientRect();

                        // Generate selector
                        const selector = generateSelector(parentElement);

                        // Get context
                        const parentText = parentElement.parentElement?.textContent?.trim().substring(0, 100) || '';
                        const siblingText = Array.from(parentElement.parentElement?.children || [])
                            .map(el => el.textContent?.trim())
                            .filter(t => t && t !== text)
                            .join(' ')
                            .substring(0, 100);

                        matches.push({
                            text: text.trim(),
                            selector,
                            elementType: parentElement.tagName.toLowerCase(),
                            elementId: parentElement.id || undefined,
                            elementClass: parentElement.className || undefined,
                            boundingBox: {
                                x: rect.x,
                                y: rect.y,
                                width: rect.width,
                                height: rect.height
                            },
                            isVisible,
                            context: {
                                parentText,
                                siblingText,
                                innerText: parentElement.innerText?.substring(0, 200) || ''
                            }
                        });
                    }

                    return matches;

                    function generateSelector(element: Element): string {
                        if (element.id) {
                            return `#${element.id}`;
                        }

                        const tagName = element.tagName.toLowerCase();
                        const classNames = Array.from(element.classList);
                        
                        if (classNames.length > 0) {
                            return `${tagName}.${classNames.join('.')}`;
                        }

                        // Generate nth-child selector
                        const parent = element.parentElement;
                        if (parent) {
                            const siblings = Array.from(parent.children);
                            const index = siblings.indexOf(element) + 1;
                            return `${tagName}:nth-child(${index})`;
                        }

                        return tagName;
                    }
                },
                { searchText, strategy, maxResults, includeHidden }
            );
        } catch (error) {
            throw new Error(`Failed to find text matches: ${error instanceof Error ? error.message : String(error)}`);
        }
    }

    private async analyzeTextDistribution(page: any, searchText: string) {
        try {
            return await page.evaluate((searchText: string) => {
                const allText = document.body.innerText || '';
                const textLength = allText.length;
                const searchLength = searchText.length;
                
                // Count occurrences
                const exactMatches = (allText.match(new RegExp(searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
                const caseInsensitiveMatches = (allText.match(new RegExp(searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi')) || []).length;
                
                // Calculate density
                const density = (caseInsensitiveMatches * searchLength) / textLength;
                
                // Get page sections with text
                const sections = {
                    header: document.querySelector('header')?.innerText?.includes(searchText) || false,
                    nav: document.querySelector('nav')?.innerText?.includes(searchText) || false,
                    main: document.querySelector('main')?.innerText?.includes(searchText) || false,
                    article: document.querySelector('article')?.innerText?.includes(searchText) || false,
                    aside: document.querySelector('aside')?.innerText?.includes(searchText) || false,
                    footer: document.querySelector('footer')?.innerText?.includes(searchText) || false
                };

                return {
                    totalPageTextLength: textLength,
                    searchTextLength: searchLength,
                    exactMatches,
                    caseInsensitiveMatches,
                    textDensity: density,
                    sectionsWithText: sections,
                    estimatedReadingTime: Math.ceil(textLength / 200) // 200 words per minute
                };
            }, searchText);
        } catch (error) {
            return {
                totalPageTextLength: 0,
                searchTextLength: searchText.length,
                exactMatches: 0,
                caseInsensitiveMatches: 0,
                textDensity: 0,
                sectionsWithText: {},
                estimatedReadingTime: 0,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    private async getTextContext(page: any, matches: TextMatch[]) {
        try {
            if (matches.length === 0) {
                return {
                    mostCommonElementType: 'none',
                    averageTextLength: 0,
                    visibilityDistribution: { visible: 0, hidden: 0 },
                    positionDistribution: { top: 0, middle: 0, bottom: 0 },
                    contextSimilarity: 0
                };
            }

            // Analyze element types
            const elementTypes = matches.map(m => m.elementType);
            const elementTypeCounts = elementTypes.reduce((acc, type) => {
                acc[type] = (acc[type] || 0) + 1;
                return acc;
            }, {} as Record<string, number>);
            
            const mostCommonElementType = Object.entries(elementTypeCounts)
                .sort(([,a], [,b]) => b - a)[0]?.[0] || 'none';

            // Calculate average text length
            const averageTextLength = matches.reduce((sum, m) => sum + m.text.length, 0) / matches.length;

            // Visibility distribution
            const visibleCount = matches.filter(m => m.isVisible).length;
            const hiddenCount = matches.length - visibleCount;

            // Position distribution (approximate)
            const viewportHeight = await page.evaluate(() => window.innerHeight);
            const positionCounts = { top: 0, middle: 0, bottom: 0 };
            
            matches.forEach(match => {
                const y = match.boundingBox.y;
                if (y < viewportHeight / 3) {
                    positionCounts.top++;
                } else if (y < (viewportHeight * 2) / 3) {
                    positionCounts.middle++;
                } else {
                    positionCounts.bottom++;
                }
            });

            // Simple context similarity (placeholder)
            const contextTexts = matches.map(m => m.context.parentText);
            const uniqueContexts = new Set(contextTexts);
            const contextSimilarity = 1 - (uniqueContexts.size / contextTexts.length);

            return {
                mostCommonElementType,
                averageTextLength,
                visibilityDistribution: { visible: visibleCount, hidden: hiddenCount },
                positionDistribution: positionCounts,
                contextSimilarity,
                elementTypeDistribution: elementTypeCounts
            };

        } catch (error) {
            return {
                mostCommonElementType: 'unknown',
                averageTextLength: 0,
                visibilityDistribution: { visible: 0, hidden: 0 },
                positionDistribution: { top: 0, middle: 0, bottom: 0 },
                contextSimilarity: 0,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }
}